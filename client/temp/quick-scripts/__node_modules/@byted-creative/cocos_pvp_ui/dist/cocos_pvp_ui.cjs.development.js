(function() {"use strict";var __module = CC_EDITOR ? module : {exports:{}};var __filename = 'preview-scripts/__node_modules/@byted-creative/cocos_pvp_ui/dist/cocos_pvp_ui.cjs.development.js';var __require = CC_EDITOR ? function (request) {return cc.require(request, require);} : function (request) {return cc.require(request, __filename);};function __define (exports, require, module) {cc._RF.push(module, '', 'cocos_pvp_ui.cjs.development', __filename);'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pvp_microphone = require('@byted-creative/pvp_microphone');
var live_ui_source = require('@byted-creative/live_ui_source');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var IMAGEURLS = [live_ui_source.BACKGROUNDIMG, live_ui_source.DEFAULTAVATAR, live_ui_source.AVATARBGMIN, live_ui_source.AVATARBGMID, live_ui_source.AVATARBGMAX, live_ui_source.LITTLECIRCLE, live_ui_source.BIGCIRCLE, live_ui_source.MATCHIMG, live_ui_source.MATCHSUCCESS, live_ui_source.LEAVEBTN, live_ui_source.REDCIRCLE, live_ui_source.ZHIBOZHONG];
var PLAYERNUM;

(function (PLAYERNUM) {
  PLAYERNUM[PLAYERNUM["TWO"] = 2] = "TWO";
  PLAYERNUM[PLAYERNUM["THREE"] = 3] = "THREE";
  PLAYERNUM[PLAYERNUM["FOUR"] = 4] = "FOUR";
  PLAYERNUM[PLAYERNUM["FIVE"] = 5] = "FIVE";
  PLAYERNUM[PLAYERNUM["SIX"] = 6] = "SIX";
  PLAYERNUM[PLAYERNUM["SEVEN"] = 7] = "SEVEN";
  PLAYERNUM[PLAYERNUM["EIGHT"] = 8] = "EIGHT";
  PLAYERNUM[PLAYERNUM["NINE"] = 9] = "NINE";
})(PLAYERNUM || (PLAYERNUM = {}));

var IMAGETYPE;

(function (IMAGETYPE) {
  IMAGETYPE[IMAGETYPE["BACKGROUNDIMG"] = 0] = "BACKGROUNDIMG";
  IMAGETYPE[IMAGETYPE["DEFAULTAVATAR"] = 1] = "DEFAULTAVATAR";
  IMAGETYPE[IMAGETYPE["AVATARBGMIN"] = 2] = "AVATARBGMIN";
  IMAGETYPE[IMAGETYPE["AVATARBGMID"] = 3] = "AVATARBGMID";
  IMAGETYPE[IMAGETYPE["AVATARBGMAX"] = 4] = "AVATARBGMAX";
  IMAGETYPE[IMAGETYPE["LITTLECIRCLE"] = 5] = "LITTLECIRCLE";
  IMAGETYPE[IMAGETYPE["BIGCIRCLE"] = 6] = "BIGCIRCLE";
  IMAGETYPE[IMAGETYPE["MATCHIMG"] = 7] = "MATCHIMG";
  IMAGETYPE[IMAGETYPE["MATCHSUCCESS"] = 8] = "MATCHSUCCESS";
  IMAGETYPE[IMAGETYPE["LEAVEBTN"] = 9] = "LEAVEBTN";
  IMAGETYPE[IMAGETYPE["REDCIRCLE"] = 10] = "REDCIRCLE";
  IMAGETYPE[IMAGETYPE["ZHIBOZHONG"] = 11] = "ZHIBOZHONG";
})(IMAGETYPE || (IMAGETYPE = {}));

var DESIGNWIDTH = 1125;
var DESIGNHEIGHT = 2001;
var DESIGNASPECT = DESIGNWIDTH / DESIGNHEIGHT;

var MatchUICocos =
/*#__PURE__*/

/** @class */
function () {
  function MatchUICocos() {
    this._avatars = [];
    this._lastFrameTime = 0;
    this._deltaTime = 0;
    this._tipUpdateGap = 0;
    this._delayClose = 0;
    this._loadingNodes = [];
    this._myOpenId = '';
    this._closeResolve = null;
    this._avartarLayout = {
      '2': [{
        x: -168,
        y: 35
      }, {
        x: 168,
        y: 35
      }],
      '3': [{
        x: -230,
        y: 20
      }, {
        x: 0,
        y: 20
      }, {
        x: 230,
        y: 20
      }],
      '4': [{
        x: -250,
        y: 20
      }, {
        x: -80,
        y: 20
      }, {
        x: 80,
        y: 20
      }, {
        x: 250,
        y: 20
      }],
      '5': [{
        x: -230,
        y: 120
      }, {
        x: 0,
        y: 120
      }, {
        x: 230,
        y: 120
      }, {
        x: -120,
        y: -80
      }, {
        x: 120,
        y: -80
      }],
      '6': [{
        x: -230,
        y: 120
      }, {
        x: 0,
        y: 120
      }, {
        x: 230,
        y: 120
      }, {
        x: -230,
        y: -80
      }, {
        x: 0,
        y: -80
      }, {
        x: 230,
        y: -80
      }],
      '7': [{
        x: -250,
        y: 120
      }, {
        x: -80,
        y: 120
      }, {
        x: 80,
        y: 120
      }, {
        x: 250,
        y: 120
      }, {
        x: -160,
        y: -80
      }, {
        x: 0,
        y: -80
      }, {
        x: 160,
        y: -80
      }],
      '8': [{
        x: -250,
        y: 120
      }, {
        x: -80,
        y: 120
      }, {
        x: 80,
        y: 120
      }, {
        x: 250,
        y: 120
      }, {
        x: -250,
        y: -80
      }, {
        x: -80,
        y: -80
      }, {
        x: 80,
        y: -80
      }, {
        x: 250,
        y: -80
      }],
      '9': [{
        x: -230,
        y: 240
      }, {
        x: 0,
        y: 240
      }, {
        x: 230,
        y: 240
      }, {
        x: -230,
        y: 15
      }, {
        x: 0,
        y: 15
      }, {
        x: 230,
        y: 15
      }, {
        x: -230,
        y: -180
      }, {
        x: 0,
        y: -180
      }, {
        x: 230,
        y: -180
      }]
    };
    this._bgType = {
      '2': IMAGETYPE.AVATARBGMIN,
      '3': IMAGETYPE.AVATARBGMIN,
      '4': IMAGETYPE.AVATARBGMIN,
      '5': IMAGETYPE.AVATARBGMID,
      '6': IMAGETYPE.AVATARBGMID,
      '7': IMAGETYPE.AVATARBGMID,
      '8': IMAGETYPE.AVATARBGMID,
      '9': IMAGETYPE.AVATARBGMAX
    };
  }

  Object.defineProperty(MatchUICocos, "instance", {
    get: function () {
      MatchUICocos._instance = new MatchUICocos();
      return MatchUICocos._instance;
    },
    enumerable: true,
    configurable: true
  });

  MatchUICocos.prototype.createUI = function () {
    return __awaiter(this, void 0, void 0, function () {
      var viewRect, curScreeRate, canvas, bg, avatarBG, avatarBGSprite, tipNode, i, loadingNode, i, avatarNode;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (this._matchUI) {
              return [2
              /*return*/
              ];
            }

            viewRect = cc.view.getVisibleSize();
            curScreeRate = viewRect.width / viewRect.height;

            if (curScreeRate > DESIGNASPECT) {
              MatchUICocos._scale = viewRect.height / DESIGNHEIGHT;
            } else {
              MatchUICocos._scale = viewRect.width / DESIGNWIDTH;
            }

            canvas = cc.director.getScene().getChildByName('Canvas');
            this._canvas = canvas;
            this._matchUI = new cc.Node('matchUI');

            this._canvas.addChild(this._matchUI);

            this._matchUI.width = DESIGNWIDTH;
            this._matchUI.height = DESIGNHEIGHT;

            this._matchUI.setSiblingIndex(Number.MAX_VALUE);

            this._matchUI.setPosition(this._canvas.width * (0.5 - this._canvas.anchorX), this._canvas.height * (0.5 - this._canvas.anchorY));

            bg = new cc.Node('bg');
            bg.addComponent(cc.Sprite);

            this._matchUI.addChild(bg);

            bg.on(cc.Node.EventType.TOUCH_END, function (e) {
              e && e.stopPropagation();
            });
            avatarBG = new cc.Node('avatarBG');
            avatarBGSprite = avatarBG.addComponent(cc.Sprite);
            avatarBGSprite.type = cc.Sprite.Type.SIMPLE;
            avatarBGSprite.sizeMode = cc.Sprite.SizeMode.RAW;

            this._matchUI.addChild(avatarBG);

            tipNode = new cc.Node('tipSprite');
            this._tipSprite = tipNode.addComponent(cc.Sprite);

            this._matchUI.addChild(tipNode);

            this._loadingNodeParent = new cc.Node('loadingNodeParent');

            this._matchUI.addChild(this._loadingNodeParent);

            for (i = 0; i < 5; i++) {
              loadingNode = new cc.Node('loadingNode' + i);
              loadingNode.addComponent(cc.Sprite);

              this._loadingNodeParent.addChild(loadingNode);

              this._loadingNodes.push(loadingNode);
            }

            for (i = 0; i < 9; i++) {
              avatarNode = this.createAvatarNode(this._matchUI);

              this._avatars.push(avatarNode);
            } // const exitBtn = new cc.Node('exitBtn');
            // exitBtn.addComponent(cc.Sprite);
            // exitBtn.addComponent(cc.Button);
            // exitBtn.getComponent(cc.Button).transition = cc.Button.Transition.SCALE;
            // exitBtn.getComponent(cc.Button).zoomScale = 0.8;
            // exitBtn.getComponent(cc.Button).duration = 0.1;
            // exitBtn.on('click', this.onClose, this);
            // this._matchUI.addChild(exitBtn);


            this._matchUI.active = false;
            return [4
            /*yield*/
            , this.loadImages(IMAGEURLS).then(function (spriteFrames) {
              _this._spriteFrames = spriteFrames;

              if (_this._matchUI) {
                _this._matchUI.width = canvas.width;
                _this._matchUI.height = canvas.height;

                var bg_1 = _this._matchUI.getChildByName('bg');

                bg_1.getComponent(cc.Sprite).spriteFrame = spriteFrames[IMAGETYPE.BACKGROUNDIMG];
                bg_1.getComponent(cc.Sprite).type = cc.Sprite.Type.SIMPLE;
                bg_1.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.CUSTOM;
                bg_1.width = canvas.width;
                bg_1.height = canvas.height;

                for (var i = 0; i < _this._loadingNodes.length; i++) {
                  _this._loadingNodes[i].getComponent(cc.Sprite).spriteFrame = spriteFrames[IMAGETYPE.LITTLECIRCLE];
                  _this._loadingNodes[i].getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.RAW;

                  _this._loadingNodes[i].setPosition(64 - 32 * (4 - i), 0);
                } // const exitBtn = this._matchUI.getChildByName('exitBtn');
                // exitBtn.getComponent(cc.Sprite).spriteFrame =
                //     spriteFrames[IMAGETYPE.LEAVEBTN];
                // exitBtn.setPosition(
                //     this._matchUI.anchorX * this._matchUI.width -
                //     exitBtn.width / 2 -
                //     30,
                //     -this._matchUI.anchorY * this._matchUI.height +
                //     exitBtn.height / 2 +
                //     100
                // );

              }

              for (var i = 0; i < _this._avatars.length; i++) {
                var sprite = _this._avatars[i].getChildByName('mask').getChildByName('sprite');

                sprite.getComponent(cc.Sprite).spriteFrame = spriteFrames[IMAGETYPE.DEFAULTAVATAR];
                sprite.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.RAW; // sprite.width = 120;
                // sprite.height = 120;

                var circle = _this._avatars[i].getChildByName('circle');

                circle.getComponent(cc.Sprite).spriteFrame = spriteFrames[IMAGETYPE.REDCIRCLE];
                circle.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.RAW;
                var zhibozhong = circle.getChildByName('zhibozhong');
                zhibozhong.getComponent(cc.Sprite).spriteFrame = spriteFrames[IMAGETYPE.ZHIBOZHONG];
                zhibozhong.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.RAW;

                var label = _this._avatars[i].getChildByName('label');

                label.getComponent(cc.Label).string = '等待中';
                label.getComponent(cc.Label).fontSize = 26; // this._avatars[i].active = false;
              }
            })];

          case 1:
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MatchUICocos.prototype.loadImages = function (urls) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , Promise.all(urls.map(function (element, index) {
          return new Promise(function (resolve) {
            var image = new window.Image();
            image.crossOrigin = "anonymous";

            image.onload = function () {
              var texture = new cc.Texture2D();
              texture.initWithElement(image);
              texture.handleLoadedTexture();
              var spriteFrame = new cc.SpriteFrame(texture);
              spriteFrame.name = index.toString();
              var size = spriteFrame.getOriginalSize(); // console.log('original size ',size);

              spriteFrame.setOriginalSize(new cc.Size(size.width * MatchUICocos._scale, size.height * MatchUICocos._scale)); // console.log('new size ',spriteFrame.getOriginalSize());

              resolve(spriteFrame);
            };

            image.src = element;
          });
        }))];
      });
    });
  };

  MatchUICocos.prototype.update = function () {
    if (!this._matchUI || !this._matchUI.active) {
      return;
    }

    this._deltaTime = 16;

    if (this._lastFrameTime) {
      this._deltaTime = Date.now() - this._lastFrameTime;
    }

    if (this._delayClose) {
      this._delayClose -= this._deltaTime;

      if (this._delayClose <= 0) {
        this._delayClose = 0;
        this.close();
      }
    }

    this._tipUpdateGap += this._deltaTime;

    if (this._tipSprite && this._tipUpdateGap >= 300 && this._spriteFrames) {
      this._tipUpdateGap = 0;
      var i = 0;

      for (; i < this._loadingNodes.length; i++) {
        var sprite = this._loadingNodes[i].getComponent(cc.Sprite);

        if (sprite.spriteFrame.name === this._spriteFrames[IMAGETYPE.BIGCIRCLE].name) {
          sprite.spriteFrame = this._spriteFrames[IMAGETYPE.LITTLECIRCLE];
          i++;
          break;
        }
      }

      i = i % this._loadingNodes.length;
      this._loadingNodes[i].getComponent(cc.Sprite).spriteFrame = this._spriteFrames[IMAGETYPE.BIGCIRCLE];
    }

    this._lastFrameTime = Date.now();
    window.requestAnimationFrame(this.update.bind(this));
  };

  MatchUICocos.prototype.show = function (playerNum, playerInfo, debug) {
    if (debug === void 0) {
      debug = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var i, i, layout, i, bgType, avatarBG;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this._delayClose = 0;
            console.log('show info', playerNum, playerInfo, debug);
            if (!!this._matchUI) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , MatchUICocos._instance.createUI()];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            if (!debug) return [3
            /*break*/
            , 4];
            return [4
            /*yield*/
            , this.createDebugUI()];

          case 3:
            _a.sent();

            _a.label = 4;

          case 4:
            if (playerNum <= 1 && playerNum >= 10) {
              return [2
              /*return*/
              ];
            }

            this.resetAvatar();

            for (i = 0; i < this._avatars.length; i++) {
              if (i < playerNum) {
                this._avatars[i].active = true;
              } else {
                this._avatars[i].active = false;
              }
            }

            if (this._loadingNodeParent) {
              this._loadingNodeParent.active = true;
            }

            if (this._spriteFrames) {
              for (i = 0; i < this._loadingNodes.length; i++) {
                this._loadingNodes[i].getComponent(cc.Sprite).spriteFrame = this._spriteFrames[IMAGETYPE.LITTLECIRCLE];
              }
            }

            if (this._avartarLayout[playerNum]) {
              layout = this._avartarLayout[playerNum];

              for (i = 0; i < layout.length; i++) {
                this._avatars[i].setPosition(layout[i].x, layout[i].y);
              }
            }

            if (this._matchUI && this._tipSprite && this._spriteFrames && this._loadingNodeParent) {
              bgType = this._bgType[playerNum] || IMAGETYPE.AVATARBGMIN;
              avatarBG = this._matchUI.getChildByName('avatarBG');
              avatarBG.getComponent(cc.Sprite).spriteFrame = this._spriteFrames[bgType];

              this._tipSprite.node.setPosition(this._tipSprite.node.position.x, avatarBG.height / 2 + 150);

              this._loadingNodeParent.setPosition(this._tipSprite.node.position.x, avatarBG.height / 2 + 80);
            }

            if (this._matchUI && this._tipSprite && this._spriteFrames) {
              this._tipSprite.spriteFrame = this._spriteFrames[IMAGETYPE.MATCHIMG];
              this._tipSprite.type = cc.Sprite.Type.SIMPLE;
              this._tipSprite.sizeMode = cc.Sprite.SizeMode.RAW;
              this._matchUI.active = true;
            }

            this._myOpenId = playerInfo.openId;
            this.setAvatar(0, playerInfo);
            window.requestAnimationFrame(this.update.bind(this));
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MatchUICocos.prototype.createDebugUI = function () {
    return __awaiter(this, void 0, void 0, function () {
      var canvas, debugButton, debugLabel;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (DebugUI.debugUI) {
              return [2
              /*return*/
              , false];
            }

            return [4
            /*yield*/
            , DebugUI.createUI()];

          case 1:
            _a.sent();

            canvas = cc.director.getScene().getChildByName('Canvas');
            debugButton = new cc.Node('debugButton');
            canvas.addChild(debugButton);
            debugButton.addComponent(cc.Button);
            debugButton.addComponent(cc.Sprite);
            debugButton.on('click', this.onDebugClick, this);
            debugButton.width = 100;
            debugButton.height = 50;
            debugLabel = new cc.Node('debugLabel');
            debugButton.addChild(debugLabel);
            debugLabel.addComponent(cc.Label);
            debugLabel.getComponent(cc.Label).string = 'vConsole'; // debugLabel.color = cc.Color.RED;

            return [4
            /*yield*/
            , this.loadImages([live_ui_source.WHITETEXTURE]).then(function (spriteFrames) {
              var sprite = debugButton.getComponent(cc.Sprite);
              sprite.spriteFrame = spriteFrames[0];
              sprite.type = cc.Sprite.Type.SLICED;
              sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
              debugButton.width = 200;
              debugButton.height = 60;
              debugButton.color = cc.Color.GREEN;
              debugButton.setPosition(-canvas.anchorX * canvas.width + debugButton.width / 2, -canvas.anchorY * canvas.height + debugButton.height / 2);
            })];

          case 2:
            // debugLabel.color = cc.Color.RED;
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MatchUICocos.prototype.onDebugClick = function () {
    if (DebugUI.isOpen()) {
      DebugUI.close();
    } else {
      DebugUI.show();
    }
  };

  MatchUICocos.prototype.whenClosed = function () {
    return this._closePromise;
  };

  MatchUICocos.prototype.matchSuccess = function (playerList) {
    return __awaiter(this, void 0, void 0, function () {
      var tempPlayerList, i, i, i, playerInfo;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this._closePromise = new Promise(function (resolve) {
              return _this._closeResolve = resolve;
            });
            return [4
            /*yield*/
            , this.playMatchSuccess()];

          case 1:
            _a.sent();

            this._delayClose = 3000;
            tempPlayerList = null; // 把我自己放在第一个

            for (i = 0; i < playerList.length; i++) {
              if (playerList[i].extraInfo.openId === this._myOpenId) {
                tempPlayerList = playerList.splice(i, 1);
                break;
              }
            }

            if (tempPlayerList) {
              for (i = 0; i < playerList.length; i++) {
                tempPlayerList.push(playerList[i]);
              }
            } else {
              tempPlayerList = playerList;
            }

            for (i = 0; i < tempPlayerList.length; i++) {
              playerInfo = tempPlayerList[i].extraInfo;
              this.setAvatar(i, playerInfo);
            }

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MatchUICocos.prototype.playMatchSuccess = function () {
    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          var finish1 = cc.callFunc(function () {
            if (_this._tipSprite && _this._spriteFrames) {
              _this._tipSprite.spriteFrame = _this._spriteFrames[IMAGETYPE.MATCHSUCCESS];
            }

            if (_this._loadingNodeParent) {
              _this._loadingNodeParent.active = false;
            }
          });
          var finish2 = cc.callFunc(function () {
            resolve();
          });
          var action = cc.sequence(cc.scaleTo(0.2, 0, 0), finish1, cc.scaleTo(0.2, 1, 1), finish2);

          if (_this._tipSprite && _this._tipSprite.node) {
            _this._tipSprite.node.runAction(action);
          }
        })];
      });
    });
  };

  MatchUICocos.prototype.setAvatar = function (index, playerInfo) {
    var _this = this;

    if (index >= this._avatars.length) {
      return;
    }

    var nickName = playerInfo.nickName,
        avatarUrl = playerInfo.avatarUrl,
        isAnchor = playerInfo.isAnchor;

    if (nickName) {
      var sprite = this._avatars[index].getChildByName('mask').getChildByName('sprite');

      var nameLabel = this._avatars[index].getChildByName('label').getComponent(cc.Label);

      var nameString = this.formatName(nickName, sprite.width * 1.2);
      nameLabel.string = nameString;
    }

    this._avatars[index].getChildByName('circle').active = isAnchor;

    if (avatarUrl) {
      this.loadImages([avatarUrl]).then(function (spriteFrames) {
        if (spriteFrames.length) {
          var sprite = _this._avatars[index].getChildByName('mask').getChildByName('sprite').getComponent(cc.Sprite);

          var width = sprite.node.width;
          var height = sprite.node.height;
          sprite.spriteFrame = spriteFrames[0];
          sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
          sprite.node.width = width;
          sprite.node.height = height;
        }
      });
    }
  };

  MatchUICocos.prototype.resetAvatar = function () {
    if (this._spriteFrames && this._avatars) {
      for (var i = 0; i < this._avatars.length; i++) {
        var maskNode = this._avatars[i] && this._avatars[i].getChildByName('mask');

        var sprite = maskNode && maskNode.getChildByName('sprite');

        if (sprite) {
          sprite.getComponent(cc.Sprite).spriteFrame = this._spriteFrames[IMAGETYPE.DEFAULTAVATAR];
          sprite.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.RAW;
        }

        var circleNode = this._avatars[i] && this._avatars[i].getChildByName('circle');

        if (circleNode) {
          circleNode.active = false;
        }

        var labelNode = this._avatars[i] && this._avatars[i].getChildByName('label');

        if (labelNode) {
          if (labelNode.getComponent(cc.Label)) {
            labelNode.getComponent(cc.Label).string = '等待中';
          }
        }
      }
    }
  };

  MatchUICocos.prototype.formatName = function (str, maxLength) {
    var pattern = new RegExp("[\u4E00-\u9FA5]+");
    var length = 0;

    for (var i = 0; i < str.length; i++) {
      if (pattern.test(str[i])) {
        length += 30;
      } else {
        length += 17;
      }

      if (length > maxLength) {
        return str.slice(0, i) + '...';
      }
    }

    return str;
  };

  MatchUICocos.prototype.close = function () {
    this.resetAvatar();

    if (this._matchUI) {
      this._matchUI.active = false;
    }

    if (this._closeResolve) {
      this._closeResolve();
    }
  }; // @ts-ignore


  MatchUICocos.prototype.onClose = function () {
    if (this._closeCallback) {
      this._closeCallback();
    }

    this.close();
  };

  MatchUICocos.prototype.setCloseEvent = function (callBack) {
    this._closeCallback = callBack;
  };

  MatchUICocos.prototype.createAvatarNode = function (avatarParent) {
    var avatarNode = new cc.Node();
    avatarNode.width = 120;
    avatarNode.height = 180;
    avatarParent.addChild(avatarNode);
    var maskNode = new cc.Node('mask');
    var mask = maskNode.addComponent(cc.Mask);
    avatarNode.addChild(maskNode);
    maskNode.width = 180 * MatchUICocos._scale;
    maskNode.height = 180 * MatchUICocos._scale; // 这里要在addchild之后再修改类型

    mask.type = cc.Mask.Type.ELLIPSE;
    var sprite = new cc.Node('sprite');
    sprite.addComponent(cc.Sprite);
    maskNode.addChild(sprite);
    var circle = new cc.Node('circle');
    circle.addComponent(cc.Sprite);
    avatarNode.addChild(circle);
    circle.active = false;
    var zhibozhong = new cc.Node('zhibozhong');
    zhibozhong.addComponent(cc.Sprite);
    circle.addChild(zhibozhong);
    zhibozhong.setPosition(0, -55);
    var labelNode = new cc.Node('label');
    labelNode.addComponent(cc.Label);
    avatarNode.addChild(labelNode);
    labelNode.anchorY = 1.0;
    labelNode.setPosition(0, -80);
    return avatarNode;
  };

  MatchUICocos._scale = 1;
  return MatchUICocos;
}();

var DebugUI =
/*#__PURE__*/

/** @class */
function () {
  function DebugUI() {}

  DebugUI.createUI = function () {
    return __awaiter(this, void 0, void 0, function () {
      var canvas, bg, scrollView, view, content, layout, label, clearButton, clearLabel;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (DebugUI._debugUI) {
              return [2
              /*return*/
              ];
            }

            canvas = cc.director.getScene().getChildByName('Canvas');
            this._debugUI = new cc.Node();
            this.debugUI = this._debugUI;
            canvas.addChild(this._debugUI);
            this._debugUI.width = 400;
            this._debugUI.height = 400;

            this._debugUI.setSiblingIndex(Number.MAX_VALUE); // this._debugUI.setPosition(
            //     -canvas.anchorX * canvas.width + this._debugUI.width / 2,
            //     -canvas.anchorY * canvas.height + this._debugUI.height / 2
            // );


            this._debugUI.setPosition(this._debugUI.width * (0.5 - canvas.anchorX), this._debugUI.height * (0.5 - canvas.anchorY));

            bg = new cc.Node('bg');
            bg.addComponent(cc.Sprite);

            this._debugUI.addChild(bg);

            scrollView = new cc.Node('scrollView').addComponent(cc.ScrollView);

            this._debugUI.addChild(scrollView.node);

            scrollView.node.width = scrollView.node.parent.width;
            scrollView.node.height = scrollView.node.parent.height;
            scrollView.horizontal = false;
            scrollView.vertical = true;
            view = new cc.Node('view');
            view.addComponent(cc.Mask);
            scrollView.node.addChild(view);
            view.width = view.parent.width;
            view.height = view.parent.height;
            content = new cc.Node('content');
            view.addChild(content);
            scrollView.content = content;
            content.width = view.width;
            layout = content.addComponent(cc.Layout);
            layout.type = cc.Layout.Type.VERTICAL;
            layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
            label = new cc.Node('label');
            this._debugLabel = label.addComponent(cc.RichText);
            content.addChild(label);
            this._debugLabel.node.color = cc.Color.BLACK;
            label.width = label.parent.width;
            this._debugLabel.fontSize = 32;
            this._debugLabel.lineHeight = 40;
            clearButton = new cc.Node('clearButton');

            this._debugUI.addChild(clearButton);

            clearButton.addComponent(cc.Button);
            clearButton.addComponent(cc.Sprite);
            clearButton.color = cc.Color.GREEN;
            clearButton.on('click', DebugUI.clearLog, DebugUI);
            clearButton.width = 100;
            clearButton.height = 50;
            clearLabel = new cc.Node('clearLabel');
            clearButton.addChild(clearLabel);
            clearLabel.addComponent(cc.Label);
            clearLabel.getComponent(cc.Label).string = 'clear';
            return [4
            /*yield*/
            , this.loadImages([live_ui_source.WHITETEXTURE]).then(function (spriteFrames) {
              _this._debugUI.width = canvas.width;
              _this._debugUI.height = canvas.height;

              var bg = _this._debugUI.getChildByName('bg');

              bg.getComponent(cc.Sprite).spriteFrame = spriteFrames[0];
              bg.getComponent(cc.Sprite).sizeMode = cc.Sprite.SizeMode.CUSTOM;
              bg.width = bg.parent.width;
              bg.height = bg.parent.height;
              scrollView.node.width = scrollView.node.parent.width;
              scrollView.node.height = scrollView.node.parent.height;
              view.width = view.parent.width;
              view.height = view.parent.height;
              content.width = content.parent.width - 50;
              label.width = label.parent.width;
              _this._debugLabel.maxWidth = label.width;
              var sprite = clearButton.getComponent(cc.Sprite);
              sprite.spriteFrame = spriteFrames[0];
              sprite.type = cc.Sprite.Type.SLICED;
              sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
              clearButton.width = 180;
              clearButton.height = 60;
              clearButton.color = cc.Color.GREEN;
              clearButton.setPosition(canvas.width * (0.5 - canvas.anchorX), -canvas.anchorY * canvas.height + clearButton.height / 2); // this._debugUI.setPosition(-canvas.anchorX * canvas.width + this._debugUI.width / 2, -canvas.anchorY * canvas.height + this._debugUI.height / 2);
            })];

          case 1:
            _a.sent();

            this._debugUI.active = false;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  DebugUI.clearLog = function () {
    this._logString = '';
    this._debugLabel.string = '';
  };

  DebugUI.loadImages = function (urls) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , Promise.all(urls.map(function (element) {
          return new Promise(function (resolve) {
            var image = new window.Image();

            image.onload = function () {
              var texture = new cc.Texture2D();
              texture.initWithElement(image);
              texture.handleLoadedTexture();
              resolve(new cc.SpriteFrame(texture));
            };

            image.src = element;
          });
        }))];
      });
    });
  };

  DebugUI.show = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!!this._debugUI) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.createUI()];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            this._debugLabel.string = this._logString;
            this._debugUI.active = true;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  DebugUI.close = function () {
    this._debugUI.active = false;
  };

  DebugUI.isOpen = function () {
    return this._debugUI.active;
  };

  DebugUI.log = function () {
    var arg = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      arg[_i] = arguments[_i];
    }

    if (this._logString) {
      this._logString += '\n';
    }

    this._logString += '<color=#000000>';

    for (var i = 0; i < arg.length; i++) {
      if (Array.isArray(arg[i])) {
        var param = arg[i];

        for (var index = 0; index < param.length; index++) {
          this._logString += typeof param[index] === 'string' ? param[index] : JSON.stringify(param[index], this.replace);
          this._seen = [];
          this._logString += ' ';
        }
      } else {
        this._logString += typeof arg[i] === 'string' ? arg[i] : JSON.stringify(arg[i], this.replace);
        this._seen = [];
        this._logString += ' ';
      }
    }

    this._logString += '</color>';
  };

  DebugUI.error = function () {
    var arg = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      arg[_i] = arguments[_i];
    }

    if (this._logString) {
      this._logString += '\n';
    }

    this._logString += '<color=#ff0000>';

    for (var i = 0; i < arg.length; i++) {
      if (Array.isArray(arg[i])) {
        var param = arg[i];

        for (var index = 0; index < param.length; index++) {
          this._logString += typeof param[index] === 'string' ? param[index] : JSON.stringify(param[index], this.replace);
          this._seen = [];
          this._logString += ' ';
        }
      } else {
        this._logString += typeof arg[i] === 'string' ? arg[i] : JSON.stringify(arg[i], this.replace);
        this._seen = [];
        this._logString += ' ';
      }
    }

    this._logString += '</color>';
  }; // @ts-ignore


  DebugUI.replace = function (key, value) {
    if (value != null && typeof value == "object") {
      if (DebugUI._seen.indexOf(value) >= 0) {
        return;
      }

      DebugUI._seen.push(value);
    }

    return value;
  };

  DebugUI._logString = '';
  DebugUI._seen = [];
  return DebugUI;
}();
var MICIMAGETYPE;

(function (MICIMAGETYPE) {
  MICIMAGETYPE[MICIMAGETYPE["MICMYOPEN"] = 0] = "MICMYOPEN";
  MICIMAGETYPE[MICIMAGETYPE["MICMYCLOSE"] = 1] = "MICMYCLOSE";
  MICIMAGETYPE[MICIMAGETYPE["MICOTHEROPEN"] = 2] = "MICOTHEROPEN";
  MICIMAGETYPE[MICIMAGETYPE["MICOTHERCLOSE"] = 3] = "MICOTHERCLOSE";
})(MICIMAGETYPE || (MICIMAGETYPE = {}));

var MicrophoneUI =
/*#__PURE__*/

/** @class */
function () {
  function MicrophoneUI() {}

  MicrophoneUI.createUI = function () {
    return __awaiter(this, void 0, void 0, function () {
      var viewRect, curScreeRate, canvas, myBtn, otherBtn;

      var _this = this;

      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (MicrophoneUI._microphoneUI) {
              return [2
              /*return*/
              ];
            }

            viewRect = cc.view.getVisibleSize();
            curScreeRate = viewRect.width / viewRect.height;

            if (curScreeRate > DESIGNASPECT) {
              MicrophoneUI._scale = viewRect.height / DESIGNHEIGHT;
            } else {
              MicrophoneUI._scale = viewRect.width / DESIGNWIDTH;
            }

            canvas = cc.director.getScene().getChildByName('Canvas');
            this._microphoneUI = new cc.Node('microphoneUI');
            this._microphoneUI.width = 200;
            this._microphoneUI.height = 64;
            canvas.addChild(this._microphoneUI);

            this._microphoneUI.setSiblingIndex(Number.MAX_VALUE);

            this._microphoneUI.setPosition((1 - canvas.anchorX) * canvas.width - this._microphoneUI.width / 2, (1 - canvas.anchorY) * canvas.height - this._microphoneUI.height / 2);

            myBtn = new cc.Node('myBtn');

            this._microphoneUI.addChild(myBtn);

            myBtn.addComponent(cc.Button);
            myBtn.setPosition(-50, -40);
            myBtn.getComponent(cc.Button).transition = cc.Button.Transition.SCALE;
            myBtn.getComponent(cc.Button).zoomScale = 0.8;
            myBtn.getComponent(cc.Button).duration = 0.1;
            this._mySprite = myBtn.addComponent(cc.Sprite);
            myBtn.on('click', this.clickMyChat, this);
            otherBtn = new cc.Node('otherBtn');

            this._microphoneUI.addChild(otherBtn);

            otherBtn.setPosition(50, -40);
            otherBtn.addComponent(cc.Button);
            otherBtn.getComponent(cc.Button).transition = cc.Button.Transition.SCALE;
            otherBtn.getComponent(cc.Button).zoomScale = 0.8;
            otherBtn.getComponent(cc.Button).duration = 0.1;
            this._otherSprite = otherBtn.addComponent(cc.Sprite);
            otherBtn.on('click', this.clickOtherChat, this);
            this._microphoneUI.active = false;
            return [4
            /*yield*/
            , this.loadImages([live_ui_source.MICMYOPEN, live_ui_source.MICMYCLOSE, live_ui_source.MICOTHEROPEN, live_ui_source.MICOTHERCLOSE]).then(function (spriteFrames) {
              _this._spriteFrames = spriteFrames;
              _this._mySprite.spriteFrame = spriteFrames[MICIMAGETYPE.MICMYOPEN];
              _this._otherSprite.spriteFrame = spriteFrames[MICIMAGETYPE.MICOTHEROPEN];
              _this._mySprite.sizeMode = cc.Sprite.SizeMode.RAW;
              _this._otherSprite.sizeMode = cc.Sprite.SizeMode.RAW;

              _this._microphoneUI.setPosition((1 - canvas.anchorX) * canvas.width - _this._microphoneUI.width / 2, (1 - canvas.anchorY) * canvas.height - _this._microphoneUI.height / 2);
            })];

          case 1:
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MicrophoneUI.loadImages = function (urls) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , Promise.all(urls.map(function (element) {
          return new Promise(function (resolve) {
            var image = new window.Image();

            image.onload = function () {
              var texture = new cc.Texture2D();
              texture.initWithElement(image);
              texture.handleLoadedTexture();
              var spriteFrame = new cc.SpriteFrame(texture);
              var size = spriteFrame.getOriginalSize();
              spriteFrame.setOriginalSize(new cc.Size(size.width * MicrophoneUI._scale, size.height * MicrophoneUI._scale));
              resolve(spriteFrame);
            };

            image.src = element;
          });
        }))];
      });
    });
  };

  MicrophoneUI.show = function (config) {
    return __awaiter(this, void 0, void 0, function () {
      var openID, roomNum, appID, source, e_1;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!!this._microphoneUI) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.createUI()];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            openID = config.openID, roomNum = config.roomNum, appID = config.appID, source = config.source;
            return [4
            /*yield*/
            , pvp_microphone.PVPMicrophone.init({
              openID: openID,
              roomNum: roomNum,
              appID: appID,
              source: source
            })];

          case 3:
            _a.sent();

            console.log('init success');
            _a.label = 4;

          case 4:
            _a.trys.push([4, 6,, 7]);

            console.log('start chat');
            return [4
            /*yield*/
            , pvp_microphone.PVPMicrophone.startChat()];

          case 5:
            _a.sent();

            return [3
            /*break*/
            , 7];

          case 6:
            e_1 = _a.sent();
            console.error('start chat', e_1);
            return [2
            /*return*/
            ];

          case 7:
            console.log('startChat success');
            this._isMyOpen = pvp_microphone.PVPMicrophone.getAudioStatus().local;
            this._isOtherOpen = pvp_microphone.PVPMicrophone.getAudioStatus().remote;
            this._microphoneUI.active = true;
            this._mySprite.spriteFrame = this._isMyOpen ? this._spriteFrames[MICIMAGETYPE.MICMYOPEN] : this._spriteFrames[MICIMAGETYPE.MICMYCLOSE];
            this._otherSprite.spriteFrame = this._isOtherOpen ? this._spriteFrames[MICIMAGETYPE.MICOTHEROPEN] : this._spriteFrames[MICIMAGETYPE.MICOTHERCLOSE];
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MicrophoneUI.close = function () {
    if (this._microphoneUI) {
      console.log('close cocos microphone ui');
      this._microphoneUI.active = false;
      pvp_microphone.PVPMicrophone.endChat();
    }
  };

  MicrophoneUI.clickMyChat = function () {
    var _this = this;

    if (this._isMyOpen) {
      pvp_microphone.PVPMicrophone.disableLocalAudio().then(function () {
        _this._isMyOpen = false;
        _this._mySprite.spriteFrame = _this._spriteFrames[MICIMAGETYPE.MICMYCLOSE];
        console.log('disableLocalAudio success');
      }).catch(function (error) {
        console.error('disableLocalAudio error', error);
      });
    } else {
      pvp_microphone.PVPMicrophone.enableLocalAudio().then(function () {
        _this._isMyOpen = true;
        _this._mySprite.spriteFrame = _this._spriteFrames[MICIMAGETYPE.MICMYOPEN];
        console.log('enableLocalAudio success');
      }).catch(function (error) {
        console.error('enableLocalAudio error', error);
      });
    }
  };

  MicrophoneUI.clickOtherChat = function () {
    var _this = this;

    if (this._isOtherOpen) {
      pvp_microphone.PVPMicrophone.muteAllRemoteAudioStream().then(function () {
        _this._isOtherOpen = false;
        _this._otherSprite.spriteFrame = _this._spriteFrames[MICIMAGETYPE.MICOTHERCLOSE];
        console.log('muteAllRemoteAudioStream success');
      }).catch(function (error) {
        console.error('muteAllRemoteAudioStream error', error);
      });
    } else {
      pvp_microphone.PVPMicrophone.unmuteAllRemoteAudioStream().then(function () {
        _this._isOtherOpen = true;
        _this._otherSprite.spriteFrame = _this._spriteFrames[MICIMAGETYPE.MICOTHEROPEN];
        console.log('unmuteAllRemoteAudioStream success');
      }).catch(function (error) {
        console.error('unmuteAllRemoteAudioStream error', error);
      });
    }
  };

  MicrophoneUI._isMyOpen = false;
  MicrophoneUI._isOtherOpen = false;
  MicrophoneUI._scale = 1;
  return MicrophoneUI;
}();

exports.DebugUI = DebugUI;
exports.MicrophoneUI = MicrophoneUI;
exports.default = MatchUICocos;

cc._RF.pop();
        }
        if (CC_EDITOR) {
            __define(__module.exports, __require, __module);
        }
        else {
            cc.registerModuleFunc(__filename, function () {
                __define(__module.exports, __require, __module);
            });
        }
        })();
        
        