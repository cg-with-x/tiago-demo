(function() {"use strict";var __module = CC_EDITOR ? module : {exports:{}};var __filename = 'preview-scripts/__node_modules/@byted-creative/pvp-client/build/match/matchTask.js';var __require = CC_EDITOR ? function (request) {return cc.require(request, require);} : function (request) {return cc.require(request, __filename);};function __define (exports, require, module) {cc._RF.push(module, '', 'matchTask', __filename);"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter3_1 = __importDefault(require("eventemitter3"));
var reqManager_1 = __importDefault(require("../common/reqManager"));
var Utils_1 = require("../common/Utils");
var common_1 = require("../common");
var errorCode_1 = require("../common/errorCode");
var log = function (res) {
};
var RETRY_INTERVALS = [1, 1, 2, 3, 5, 8];
var ACK_CMD;
(function (ACK_CMD) {
    ACK_CMD[ACK_CMD["ACK"] = 1] = "ACK";
    ACK_CMD[ACK_CMD["NOTIFY"] = 3] = "NOTIFY";
})(ACK_CMD || (ACK_CMD = {}));
var REQ_CMD;
(function (REQ_CMD) {
    REQ_CMD[REQ_CMD["START_MATCH"] = 1] = "START_MATCH";
    REQ_CMD[REQ_CMD["CANCEL_MATCH"] = 2] = "CANCEL_MATCH";
    REQ_CMD[REQ_CMD["START_TEAM_MATCH"] = 201] = "START_TEAM_MATCH";
    REQ_CMD[REQ_CMD["CANCEL_TEAM_MATCH"] = 202] = "CANCEL_TEAM_MATCH";
})(REQ_CMD || (REQ_CMD = {}));
var EVENT_ID;
(function (EVENT_ID) {
    EVENT_ID[EVENT_ID["PLAYER_ONLINE"] = 0] = "PLAYER_ONLINE";
    EVENT_ID[EVENT_ID["MATCH_START"] = 201] = "MATCH_START";
    EVENT_ID[EVENT_ID["MATCH_SUCCESS"] = 202] = "MATCH_SUCCESS";
    EVENT_ID[EVENT_ID["MATCH_CANCEL"] = 203] = "MATCH_CANCEL";
    EVENT_ID[EVENT_ID["MATCH_ERROR"] = 204] = "MATCH_ERROR";
})(EVENT_ID || (EVENT_ID = {}));
var MatchTask = (function (_super) {
    __extends(MatchTask, _super);
    function MatchTask(config, socket) {
        var _this = _super.call(this) || this;
        _this._retryTimes = 0;
        _this._config = config;
        _this._reqManager = new reqManager_1.default();
        _this.state = "ready";
        _this.matchResult = undefined;
        log("config: " + JSON.stringify(config));
        if (_this._config.isTeam && socket) {
            log("isTeam");
            _this.socket = socket;
            _this.socket.onClose(function () {
                if (_this.state !== "matched") {
                    _this.state = "matched";
                    _this.emit("close", undefined);
                }
            });
            var _a = _this._config, matchId = _a.matchId, score = _a.score;
            if (matchId) {
                var reqMsg = _this._reqManager.reqMaker(REQ_CMD.START_TEAM_MATCH, {
                    matchid: matchId,
                    score: score || 0,
                }, function (status) {
                    if (status.code !== errorCode_1.ERROR_CODE.SUCCESS) {
                        _this.state = "matched";
                        _this.emit("error", status);
                    }
                });
                log("Inner: start, " + reqMsg);
                _this.socket.send({
                    data: reqMsg,
                });
            }
        }
        else {
            _this._initConnection();
        }
        return _this;
    }
    MatchTask.prototype.destroy = function () {
        log("Method team.destroy");
        this.removeAllListeners();
        if (!this._config.isTeam) {
            this.socket.close();
        }
    };
    MatchTask.prototype.cancel = function () {
        var _this = this;
        log("Method cancel");
        return new Promise(function (resolve) {
            var msg = _this._reqManager.reqMaker(_this._config.isTeam ? REQ_CMD.CANCEL_TEAM_MATCH : REQ_CMD.CANCEL_MATCH, { matchid: _this._config.matchId }, function (status) {
                if (status.code === errorCode_1.ERROR_CODE.SUCCESS) {
                    resolve();
                }
                else {
                    _this.emit("error", status);
                }
            });
            _this.socket.send({
                data: msg,
            });
        });
    };
    MatchTask.prototype.restartMatch = function () {
        var _this = this;
        this.state = "ready";
        this.matchResult = undefined;
        this._retryTimes = 0;
        if (this._config.isTeam) {
            var _a = this._config, matchId = _a.matchId, score = _a.score;
            var reqMsg = this._reqManager.reqMaker(REQ_CMD.START_TEAM_MATCH, {
                matchid: matchId,
                score: score || 0,
            }, function (status) {
                if (status.code !== errorCode_1.ERROR_CODE.SUCCESS) {
                    _this.state = "matched";
                    _this.emit("error", status);
                }
            });
            log("Inner: start");
            this.socket.send({
                data: reqMsg,
            });
        }
        else {
            this._initConnection();
        }
    };
    MatchTask.prototype._initConnection = function () {
        var _this = this;
        var _a = this._config, appId = _a.appId, appTag = _a.appTag, session = _a.session;
        var connectionConfig = Utils_1.getMatchConnectionConfig({
            appId: appId,
            appTag: appTag,
            session: session,
        });
        this.socket = common_1.connectSocket(connectionConfig);
        this.handleMatchRes = this.handleMatchRes.bind(this);
        this.socket.onMessage(function (res) {
            _this.handleMatchRes(res.data);
        });
        this.socket.onError(function (err) {
            log(err);
            if (!_this._config.disableAutoRetry &&
                _this._retryTimes <= RETRY_INTERVALS.length - 1) {
                setTimeout(function () {
                    _this._initConnection();
                }, RETRY_INTERVALS[_this._retryTimes] * 1000);
                _this._retryTimes++;
            }
            else {
                _this.emit("error", {
                    code: errorCode_1.ERROR_CODE.SERVICE_NOT_RESPONSE,
                    message: "match server not response, please check user internet or connect with us",
                });
            }
            _this.socket.close();
        });
        this.socket.onClose(function () {
            if (_this.state !== "matched") {
                _this.state = "matched";
                _this.emit("close", undefined);
            }
        });
    };
    MatchTask.prototype.handleMatchRes = function (res, selfId) {
        var _this = this;
        log("Inner: handleMatchRes " + res);
        var parsedRes = JSON.parse(res);
        var cmd = parsedRes.cmd, code = parsedRes.code, data = parsedRes.data;
        if (typeof code !== "undefined") {
            if (code !== 0) {
                log("connect to match fail");
                this.emit("error", { code: code, message: "connect to match fail" });
            }
            return;
        }
        if (!cmd) {
            return;
        }
        switch (cmd) {
            case ACK_CMD.ACK: {
                this._reqManager.ackHandler(data);
                break;
            }
            case ACK_CMD.NOTIFY: {
                switch (data.eventid) {
                    case EVENT_ID.PLAYER_ONLINE: {
                        log("Inner: connect to match success");
                        var _a = this._config, matchId = _a.matchId, score = _a.score, playerMatchInfo = _a.playerMatchInfo, urlForPlatform = _a.urlForPlatform;
                        var notifyUrl = void 0, subscribeUrl = void 0;
                        if (urlForPlatform) {
                            notifyUrl = urlForPlatform.notifyUrl;
                            subscribeUrl = urlForPlatform.subscribeUrl;
                        }
                        var reqMsg = this._reqManager.reqMaker(REQ_CMD.START_MATCH, {
                            matchid: matchId,
                            score: score || 0,
                            notifyUrl: notifyUrl,
                            subscribeUrl: subscribeUrl,
                            extraInfo: playerMatchInfo,
                        }, function (status) {
                            if (status.code !== errorCode_1.ERROR_CODE.SUCCESS) {
                                _this.emit("error", status);
                            }
                        });
                        log("Inner: start, " + reqMsg);
                        this.socket.send({
                            data: reqMsg,
                        });
                        break;
                    }
                    case EVENT_ID.MATCH_START: {
                        this.state = "matching";
                        this.emit("start", undefined);
                        break;
                    }
                    case EVENT_ID.MATCH_SUCCESS: {
                        if (selfId) {
                            var campInfoList_1 = [];
                            var playerList_1 = [];
                            data.data.playerInfoList.forEach(function (playerInfoList) {
                                var tmpList = [];
                                playerInfoList.forEach(function (playerInfo) {
                                    tmpList.push({
                                        isMe: playerInfo.id === selfId,
                                        score: playerInfo.score,
                                        extraInfo: playerInfo.extraInfo,
                                    });
                                    playerList_1.push({
                                        isMe: playerInfo.id === selfId,
                                        score: playerInfo.score,
                                        extraInfo: playerInfo.extraInfo,
                                    });
                                });
                                campInfoList_1.push(tmpList);
                            });
                            var roomNum = data.data.ticket;
                            this.state = "matched";
                            this.matchResult = {
                                roomNum: roomNum,
                                campInfoList: campInfoList_1,
                                playerList: playerList_1,
                            };
                            this.emit("success", {
                                roomNum: roomNum,
                                campInfoList: campInfoList_1,
                                playerList: playerList_1,
                            });
                        }
                        else {
                            var roomNum = data.data.ticket;
                            var campInfoList = data.data.playerInfoList;
                            this.state = "matched";
                            var playerList_2 = [];
                            campInfoList.forEach(function (subCampInfoList) {
                                subCampInfoList.forEach(function (playerInfo) {
                                    playerList_2.push(playerInfo);
                                });
                            });
                            this.matchResult = {
                                roomNum: roomNum,
                                campInfoList: campInfoList,
                                playerList: playerList_2,
                            };
                            this.emit("success", {
                                roomNum: roomNum,
                                campInfoList: campInfoList,
                                playerList: playerList_2,
                            });
                            if (!this._config.isTeam) {
                                this.socket.close();
                            }
                        }
                        break;
                    }
                    case EVENT_ID.MATCH_CANCEL: {
                        this.state = "matched";
                        this.emit("cancel", data && data.data && data.data.status);
                        if (!this._config.isTeam) {
                            this.socket.close();
                        }
                        break;
                    }
                    case EVENT_ID.MATCH_ERROR: {
                        this.state = "matched";
                        this.emit("error", data.data.status);
                        break;
                    }
                    default:
                        this.emit("error", {
                            code: 15,
                            message: "notify unknown eventid " + data.eventid,
                        });
                        break;
                }
                break;
            }
            default:
                log("unknown message type " + cmd);
                break;
        }
    };
    return MatchTask;
}(eventemitter3_1.default));
exports.MatchTask = MatchTask;

cc._RF.pop();
        }
        if (CC_EDITOR) {
            __define(__module.exports, __require, __module);
        }
        else {
            cc.registerModuleFunc(__filename, function () {
                __define(__module.exports, __require, __module);
            });
        }
        })();
        
        